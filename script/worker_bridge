#!/usr/bin/env perl
# Copyright (C) 2017 SUSE Linux Products GmbH
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <http://www.gnu.org/licenses/>.

=head1 slave_bridge

slave_bridge - openQA slave bridge

=head1 SYNOPSIS

worker [OPTIONS]

=head2OPTIONS

=over 4

=item B<--master> https://s.ky.net.openqa.opensuse.org

=item B<--master> https://openqa.opensuse.org

=item B<--help, -h>

print help

=back

=head2 DESCRIPTION

(no content)

=head1 CONFIG FILE

L<worker> relies on credentials provided by L<OpenQA::Client>, i.e. tries to
find a config file C<client.conf> resolving C<$OPENQA_CONFIG> or
C<~/.config/openqa> or C</etc/openqa/> in this order of preference.
Additionally L<worker> uses a config file C<workers.ini> to configure worker
settings.

Example:
  [global]
  BACKEND = qemu
  HOST = http://openqa.example.com


=head1 SEE ALSO
L<OpenQA::Client>

=cut

use strict;
use warnings;

BEGIN {
    #prepare for large files
    $ENV{MOJO_MAX_MESSAGE_SIZE}   = 1024 * 1024 * 1024 * 20;
    $ENV{MOJO_INACTIVITY_TIMEOUT} = 300;
    $ENV{MOJO_CONNECT_TIMEOUT}    = 300;
    # the default is EV, and this heavily screws with our children handling
    $ENV{MOJO_REACTOR} = 'Mojo::Reactor::Poll';
    $ENV{MOJO_LOG_LEVEL} = 'debug';
    #$ENV{MOJO_USERAGENT_DEBUG} = 1;
    #$ENV{MOJO_IOLOOP_DEBUG} = 1;
}

use FindBin;
use lib "$FindBin::Bin/../lib";
use Config::IniFiles;
use Getopt::Long;
use Mojo::Base -strict;
use Mojo::UserAgent;
use Mojo::URL;
use Mojo::Log;
use OpenQA::Client;
use Mojo::IOLoop;
use JSON;

use Data::Dumper;

Getopt::Long::Configure("no_ignore_case");

my %options;

sub usage($) {
    my $r = shift;
    eval "use Pod::Usage; pod2usage($r);";
    if ($@) {
        die "cannot display help, install perl(Pod::Usage)\n";
    }
}

GetOptions(
    \%options, "master=s", "slave=s", "verbose|v", "help|h",
) or usage(1);

usage(0) if ($options{help});

my $log = Mojo::Log->new;
$options{limit} ||= 1000;
$options{worker_class} ||= ":provo:qemu_aarch64";

#"/api/v1/jobs.json?&worker_class=aarch64_seattle9&limit=1000";
my $master_url = Mojo::URL->new($options{master})->path("/api/v1/jobs.json")->query({
        limit => $options{limt},
        worker_class => $options{worker_class}
    });

my $master = OpenQA::Client->new(
        api    => $master_url->host,
        apikey => $master_url->username,
        apisecret => $master_url->password,
    );

my $slave_url = Mojo::URL->new($options{slave})->path("/api/v1/jobs");
my $slave = OpenQA::Client->new(
        api    => $slave_url->host,
        apikey => $slave_url->username,
        apisecret => $slave_url->password,
    );

$log->info("Master: ". $master_url->to_abs);
$log->info("Slave: ". $slave_url->to_abs);

my $masterUI = $master;
my $slaveUI = $slave;
my $main_loop = Mojo::IOLoop->singleton;


sub get_asset_list {
    return {a => 1};
}

sub move_job {
    my ($job) = @_;
    my %settings = %{$job->{settings}};
    if ($job->{group}) {
        $settings{_GROUP} = $job->{group};
    }
    delete $settings{NAME};
    $settings{WORKER_CLASS} =~ s/:provo://;
    $settings{PROXIED} = 1;

    # print JSON->new->pretty->encode(\%settings) if ($options{verbose});
    my $url = $slave_url->clone;
    $settings{federated_report} = $master_url->scheme . '://' . $master_url->host().'/tests/'.$job->{id};
    $log->info("Posting to: ".$url->to_abs);
    $url->query(%settings);
    my $tx = $slaveUI->post($url);
    if ($tx->success) {
        my $remote_id = $tx->success->json->{id};
        if ($remote_id) {
            my $new_url = $slave_url->scheme . '://' . $slave_url->host . '/tests/' . $remote_id;
            $log->info( "Created job #$remote_id: ".$job->{name}." -> $new_url\n");
            update_proxied_job($job, $master_url->clone, {proxied => 1});
            return { jobid => $remote_id, remote_url => $settings{federated_report}, slave_url => $new_url };
        }
        else {
            die "job not created. duplicate? ", pp($tx->res->body);
        }
    }
    else {
        die "Failed to create job, empty response. Make sure your HTTP proxy is running, e.g. apache, nginx, etc."
          unless $tx->res->body;
        die "Failed to create job: ", pp($tx->res->body);
    }
}

sub fetch_jobs {
    my @crop;
    my $UI = $masterUI->get($master_url->clone);
    $log->debug("fetching jobs from".$master_url->clone);
    if($UI->res->is_success){
        my $job_count = scalar @{$UI->res->json->{jobs}};
        $log->info("Found: $job_count at ". $master_url->to_abs);
        foreach my $job (@{$UI->res->json->{jobs}}){
            my $seed = move_job($job);
            push @crop, $seed if $seed;
        }
    } else {
        $log->info("Nothing found?". $master_url->to_abs);
    }
    return @crop;
}

sub update_proxied_job {
    my ($job, $url, $status) = @_;
    $url->path("jobs/".$job->{id}."/status");
    my $js = {status => $status};
    # $url->query($js);
    $log->info("Updating job: ".$job->{id}." at the MasterUI");
    my $tx = $master->post($url => json => $js);
    if ($tx->success) {
        my $req = $tx->success->json;
        if ($req) {
            $log->debug("Job #".$job->{id}." sucessully updated in the MasterUI");
            return 1;
        } else {
            die "job not created. duplicate? ", Dumper($tx->res->body);
        }
    }
    else {
        die "Failed to create job, empty response. Make sure your HTTP proxy is running, e.g. apache, nginx, etc."
          unless $tx->res->body;
        die "Failed to create job: ", Dumper($tx->res->body);
    }
}

sub proxy_job_monitor {
    my ($result) = @_;
    $log->debug("proxy_job_monitor: ".$result->{jobid});
    $main_loop->recurring(2 => sub {
        my $loop = shift;
        # Add a timer
        $log->error("Adding a monitor for #".$result->{jobid}, Dumper($result));

        Mojo::IOLoop->subprocess(
            sub {
                    $log->info("Checking for job #".$result->{jobid}, Dumper($result));
                    my $url = $slave_url->clone;
                    $url->path("jobs/".$result->{jobid});
                    my $UI = $slaveUI->get($url);
                    $log->info("Job #". $result->{jobid} ." reported ".$UI->res->json->{job}{state});
                    if($UI->res->is_success){
                        my $job_status = $UI->res->json->{state};
                        $log->info("Job #". $result->{jobid} ." reported ".$UI->res->json->{job}{state});
                        $log->info(Dumper($result));
                        $log->info(Dumper($UI->res->json));
                        update_proxied_job(id => $result->{jobid}, $master_url->clone, passed => 1) if $UI->res->json->{job}{state} eq 'done' ;
                        update_proxied_job(id => $result->{jobid}, $master_url->clone, incomplete => 1) if $UI->res->json->{job}{state} eq 'scheduled' ;
                    }
            },
            sub {
            my ($subprocess, $err, @results) = @_;
            $subprocess->ioloop->emit('job_progress', @results);
        });
    });

}

$main_loop->on(new_jobs => sub {
    my ($loop, @report_args) = @_;
    $log->info("Job progress on the SlaveUI", Dumper(\@report_args));
    map { proxy_job_monitor($_) } @report_args;
    });

$main_loop->on(job_progress => sub {
    my ($loop, @report_args) = @_;
    $log->info("Job progress on the SlaveUI");
    });

#Check for new jobs on the master webUI
$main_loop->recurring(5 => sub {
    my $loop = shift;
    # Add a timer
    $log->info("Checking for new jobs on the MasterUI");
    Mojo::IOLoop->subprocess(
        sub {
            my $subprocess = shift;
            $log->debug("Checking for new jobs");
            my @jobs = fetch_jobs();
            $log->info("New jobs monitoring finished");
            return @jobs;
        },
        sub {
        my ($subprocess, $err, @results) = @_;
        if (@results){
            map { $log->debug("Job ".$_->{jobid}." created at ". $_->{slave_url}) } @results;
            $log->info("Jobs available on the MasterUI");
            $subprocess->ioloop->emit('new_jobs', @results);
        }
    });
});

Mojo::IOLoop->start;

# vim: set sw=4 sts=4 et:
