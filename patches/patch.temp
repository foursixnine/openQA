 docs/index.asciidoc                |   1 +
 lib/OpenQA/Parser/Format/JUnit.pm  |   5 +-
 lib/OpenQA/Parser/Format/TAP.pm    |  98 +++++-----
 lib/OpenQA/Parser/Result/OpenQA.pm |   4 +-
 lib/OpenQA/Worker/Jobs.pm          |   6 +-
 script/clone_job.pl                |   9 +-
 t/30-test_parser.t                 |  59 ++----
 t/data/tap_format_example.tap      | 368 ++-----------------------------------
 8 files changed, 97 insertions(+), 453 deletions(-)

diff --git a/docs/index.asciidoc b/docs/index.asciidoc
index acfb83ce..724d9e94 100644
--- a/docs/index.asciidoc
+++ b/docs/index.asciidoc
@@ -13,6 +13,7 @@ include::GettingStarted.asciidoc[]
 include::Installing.asciidoc[]
 include::UsersGuide.asciidoc[]
 include::WritingTests.asciidoc[]
+include::ExternalResults.asciidoc[]
 include::Pitfalls.asciidoc[]
 include::Networking.asciidoc[]
 include::Contributing.asciidoc[]
diff --git a/lib/OpenQA/Parser/Format/JUnit.pm b/lib/OpenQA/Parser/Format/JUnit.pm
index 63e75282..145b38ad 100644
--- a/lib/OpenQA/Parser/Format/JUnit.pm
+++ b/lib/OpenQA/Parser/Format/JUnit.pm
@@ -165,13 +165,16 @@ With the attribute C<include_result()> set to true, it will include inside the
 results the respective test that generated it (inside the C<test()> attribute).
 See also L<OpenQA::Parser::Result::OpenQA>.
 
+JUnit format is specific for slenkins tests. If you wish to use generic JUnit format,
+use XUnit format instead.
+
 =head1 ATTRIBUTES
 
 OpenQA::Parser::Format::JUnit inherits all attributes from L<OpenQA::Parser::Format::Base>.
 
 =head1 METHODS
 
-OpenQA::Parser::Format::Base inherits all methods from L<OpenQA::Parser::Format::Base>, it only overrides
+OpenQA::Parser::Format::JUnit inherits all methods from L<OpenQA::Parser::Format::Base>, it only overrides
 C<parse()> to generate a tree of results.
 
 =cut
diff --git a/lib/OpenQA/Parser/Format/TAP.pm b/lib/OpenQA/Parser/Format/TAP.pm
index 00df2ee1..0aa1b397 100644
--- a/lib/OpenQA/Parser/Format/TAP.pm
+++ b/lib/OpenQA/Parser/Format/TAP.pm
@@ -19,12 +19,13 @@ use Mojo::Base 'OpenQA::Parser::Format::Base';
 use Carp qw(croak confess);
 use OpenQA::Parser::Result::OpenQA;
 use TAP::Parser;
+use Data::Dumper;
 
-has include_results => 0;
-has [qw(_tap)];
+has [qw(test steps)];
 
 # Override to use specific OpenQA Result class.
 sub _add_single_result { shift->generated_tests_results->add(OpenQA::Parser::Result::OpenQA->new(@_)) }
+
 sub _add_result {
     my $self = shift;
     my %opts = ref $_[0] eq 'HASH' ? %{$_[0]} : @_;
@@ -48,47 +49,60 @@ sub parse {
     confess "No TAP given/loaded" unless $TAP;
     my $tap = TAP::Parser->new({ tap => $TAP });
     confess "Failed ".$tap->parse_errors if $tap->parse_errors ;
-
+    my $test =
+        {
+            flags    => {},
+            category => "TAP",
+            name     =>  'Extra test from TAP',
+        };
+    $self->steps(OpenQA::Parser::Results->new);
+    my $details;
+    my $m = 0;
     while (my $res = $tap->next) {
         my $result =  $res;
-        next if $result->type ne 'test';
-        my $t_name = $res->{description};
-        # Only because it happened also for LTP
-        $t_name =~ s/:/_/g;
-
-        $result->{result} = 'ok';
-        $result->{result} = 'fail' unless $result->is_actual_ok;
-        $result->{name} = $t_name;
+        # For the time being only load known types
+        # Tests are supported and comments too
+        # print Dumper($result);
+
+        if( $result->raw =~  m/^(.*\.tap) \.{2}/g)  {
+            $details = { result => 'failed' };
+            # most cases, teh output of a prove run will contain
+            # "/t/$filename.tap .." as name of the file
+            # use this to get the filename
+            $test->{name} =$1;
+            $test->{name} =~ s/\//_/;
+            $test->{result} = ($tap->failed)? 'failed' : 'passed';
+            $self->test(OpenQA::Parser::Result->new($test));
+            next;
+        } else {
+            confess "A valid TAP starts with filename.tap, and got: '@{[$result->raw]}'" unless $self->test;
+        }
 
         # stick for now to only test results.
-        my $details
-          = {result => ($result->is_actual_ok)? 'ok' : 'fail'};
-
-        $details->{text}  = $res->as_string;
-        $details->{title} = $t_name;
+        next if $result->type eq 'plan'; # Skip plans for now
+        next if $result->type ne 'test';
 
-        push @{$result->{details}}, $details;
+        my $t_filename = "TAP-@{[$test->{name}]}-$m.txt";
+        $details = {
+            text  => $t_filename,
+            title => $result->raw,
+            result => ($result->is_actual_ok)? 'passed' : 'fail',
+        };
 
+        # Ensure that text files are going to be written
+        # With the content that is relevant
         $self->_add_output(
             {
-                file    => "TAP-$t_name.txt",
+                file    => $t_filename,
                 content => $res->raw
             });
-
-        #        my $t = OpenQA::Parser::Result::LTP::SubTest->new(
-        #    flags    => {},
-        #    category => 'LTP',
-        #    name     => $t_name,
-        #    log      => $res->{test}->{log},
-        #    duration => $res->{test}->{duration},
-        #    script   => undef,
-        #    result   => $res->{test}->{result});
-        #$self->tests->add($t);
-        #$result->{test} = $t if $self->include_results();
-        $self->_add_single_result($result);
+        #$result->{name} = $test->{name};
+        my $data = {%$result, %$details};
+        push @{$test->{steps}}, $details;
+        $self->_add_result($data);
+        ++$m;
     }
-
-    $self;
+    $self->_add_test($self->test);
 }
 
 =encoding utf-8
@@ -99,16 +113,14 @@ OpenQA::Parser::Format::TAP - TAP file parser
 
 =head1 SYNOPSIS
 
-    use OpenQA::Parser::Format::JUnit;
+    use OpenQA::Parser::Format::TAP;
 
-    my $parser = OpenQA::Parser::Format::JUnit->new()->load('file.xml');
+    my $parser = OpenQA::Parser::Format::TAP->new()->load('test.tap');
 
     # Alternative interface
     use OpenQA::Parser qw(parser p);
 
-    my $parser = p('JUnit')->include_result(1)->load('file.xml');
-
-    my $parser = parser( JUnit => 'file.xml' );
+    my $parser = parser( TAP => 'test.tap' );
 
     my $result_collection = $parser->results();
     my $test_collection   = $parser->tests();
@@ -124,21 +136,17 @@ OpenQA::Parser::Format::TAP - TAP file parser
 
 =head1 DESCRIPTION
 
-OpenQA::Parser::Format::JUnit is the parser for junit file format.
+OpenQA::Parser::Format::TAP is the parser for Test Anything Protocol format.
 The parser is making use of the C<tests()>, C<results()> and C<output()> collections.
 
-With the attribute C<include_result()> set to true, it will include inside the
-results the respective test that generated it (inside the C<test()> attribute).
-See also L<OpenQA::Parser::Result::OpenQA>.
-
 =head1 ATTRIBUTES
 
-OpenQA::Parser::Format::JUnit inherits all attributes from L<OpenQA::Parser::Format::Base>.
+OpenQA::Parser::Format::TAP inherits all attributes from L<OpenQA::Parser::Format::Base>.
 
 =head1 METHODS
 
-OpenQA::Parser::Format::Base inherits all methods from L<OpenQA::Parser::Format::Base>, it only overrides
-C<parse()> to generate a tree of results.
+OpenQA::Parser::Format::TAP inherits all methods from L<OpenQA::Parser::Format::Base>, it only overrides
+C<parse()> to generate a simple tree of results.
 
 =cut
 
diff --git a/lib/OpenQA/Parser/Result/OpenQA.pm b/lib/OpenQA/Parser/Result/OpenQA.pm
index 251f264f..38431d15 100644
--- a/lib/OpenQA/Parser/Result/OpenQA.pm
+++ b/lib/OpenQA/Parser/Result/OpenQA.pm
@@ -48,9 +48,9 @@ sub TO_JSON {
         details => $_[0]->details(),
         (test => $_[0]->test ? $_[0]->test->TO_JSON : undef) x !!($_[1])};
 }
-
+use Data::Dumper;
 # Override to get automatically the file name
-sub write { $_[0]->SUPER::write(path($_[1], join('.', join('-', 'result', $_[0]->name), 'json'))) }
+sub write { print Dumper($_); $_[0]->SUPER::write(path($_[1], join('.', join('-', 'result', $_[0]->name), 'json'))) }
 
 {
     package OpenQA::Parser::Result::OpenQA::Results;
diff --git a/lib/OpenQA/Worker/Jobs.pm b/lib/OpenQA/Worker/Jobs.pm
index 08f0c3f0..b1d3f3cc 100644
--- a/lib/OpenQA/Worker/Jobs.pm
+++ b/lib/OpenQA/Worker/Jobs.pm
@@ -524,7 +524,11 @@ sub start_job {
 
     # update settings with worker-specific stuff
     copy_job_settings($job, $worker_settings);
-
+    unlink("$pooldir/autoinst-log.txt");
+    open(my $fd, '>', "$pooldir/worker-log.txt");
+	print $fd, "";
+    unlink("$pooldir/serial_terminal.txt");
+    unlink("$pooldir/serial0.txt.txt");
     my $name = $job->{settings}->{NAME};
     log_info(sprintf('got job %d: %s', $job->{id}, $name));
 
diff --git a/script/clone_job.pl b/script/clone_job.pl
index 6dfdfe1c..51e3c8e3 100755
--- a/script/clone_job.pl
+++ b/script/clone_job.pl
@@ -48,7 +48,7 @@ get job from specified host
 
 =item B<--dir> DIR
 
-specify directory where test assets are stored (default /var/lib/openqa/factory)
+specify directory where test assets are stored (default /var/lib/openqa/factory), if OPENQA_BASEDIR is set, this parameter is ignored
 
 =item B<--skip-deps>
 
@@ -110,6 +110,7 @@ use Getopt::Long;
 use LWP::UserAgent;
 Getopt::Long::Configure("no_ignore_case");
 use Mojo::URL;
+use Mojo::File qw(path);
 use JSON;
 use FindBin;
 use lib "$FindBin::RealBin/../lib";
@@ -135,6 +136,12 @@ usage(1) unless @ARGV;
 usage(1) unless exists $options{'from'};
 
 my $jobid = shift @ARGV || die "missing jobid\n";
+if ($ENV{OPENQA_BASEDIR}){
+    # If the user has it's own OPENQA_BASEDIR, assume that dir can be safely
+    # overwritten
+    warn "OPENQA_BASEDIR is also set" if $options{'dir'};
+    $options{'dir'} ||= path($ENV{OPENQA_BASEDIR}, 'openqa','share', 'factory');
+}
 
 $options{'dir'} ||= '/var/lib/openqa/factory';
 
diff --git a/t/30-test_parser.t b/t/30-test_parser.t
index b933d462..a3a85e00 100644
--- a/t/30-test_parser.t
+++ b/t/30-test_parser.t
@@ -550,19 +550,12 @@ subtest junit_parse => sub {
 
 sub test_tap_file {
     my $p = shift;
-    is $p->results->size, 200, 'Expected 200 results';
-    my $i = 2;
+    is $p->results->size, 6, 'Expected 6 results';
     $p->results->each(
         sub {
-            is $_->result, 'ok', 'Tests passed' or diag explain $_;
-            #ok !!$_->environment, 'Environment is present';
-            ok !!$_->test,        'Test information is present';
-            #is $_->environment->gcc, 'gcc (SUSE Linux) 7.2.1 20170927 [gcc-7-branch revision 253227]',  'Environment information matches';
-            #is $_->test->result, 'TPASS', 'subtest result is TPASS' or diag explain $_;
-            is $_->test_fqn, "LTP:cpuhotplug:cpuhotplug0$i", "test_fqn matches and are different";
-            $i++;
+            is $_->result, 'pass', 'Tests passed';
+            is $_->details->[0]->{result}, 'pass', "Test has ok" or diag explain $_;
         });
-    #is $p->results->get(0)->environment->gcc, 'gcc (SUSE Linux) 7.2.1 20170927 [gcc-7-branch revision 253227]', 'Environment information matches';
 }
 
 subtest tap_parse => sub {
@@ -570,48 +563,18 @@ subtest tap_parse => sub {
 
     my $tap_test_file = path($FindBin::Bin, "data")->child("tap_format_example.tap");
 
-    $parser->load($tap_test_file);
-    my $expected_test_result = test_tap_file($parser);
-    diag $expected_test_result;
-    #$expected_test_result->{test} = undef;
-    #is_deeply $parser->results->last->TO_JSON(1), $expected_test_result,
-    #  'Expected test result match - with no include_results - forcing to output the test';
-    #$expected_test_result->{name} = '9_post-tests_audits';
-    #delete $expected_test_result->{test};
-
-    #is_deeply $parser->results->last->to_hash(), $expected_test_result,
-    #  'Expected test result match - with no include_results - forcing to output the test';
-    #delete $expected_test_result->{name};
-
     $parser = OpenQA::Parser::Format::TAP->new;
-
-    $parser->include_results(1);
     $parser->load($tap_test_file);
 
-    diag $parser->results->size;
-    diag $parser->results;
-    #  'Generated 9 openQA tests results';    # 9 testsuites with all cumulative results for openQA
-
-    #is_deeply $parser->results->last->TO_JSON(0), $expected_test_result, 'Test is hidden';
-
-    #$expected_test_result->{test} = {
-    #    'category' => 'tests-systemd',
-    #    'flags'    => {},
-    #    'name'     => '9_post-tests_audits',
-    #    'script'   => 'unk'
-    #};
+    is $parser->results->size, 6, "File has 6 test cases";
 
-    #is_deeply $parser->results->last->TO_JSON(1), $expected_test_result, 'Test is showed';
+    is $parser->results->first->result, 'pass', 'First testsuite fails as testcases passing failing';
+    is scalar @{$parser->results->first->details}, 1, '1 test cases details';
 
-    #$parser = OpenQA::Parser::Format::JUnit->new;
+    is $parser->results->last->result, 'pass', 'First testsuite fails as testcases passing failing';
+    is scalar @{$parser->results->last->details}, 1, '1 test cases details';
 
-    #$junit_test_file = path($FindBin::Bin, "data")->child("slenkins_control-junit-results-fail.xml");
-
-    $parser->load($tap_test_file);
-
-    is $parser->results->first->result, 'fail', 'First testsuite fails as testcases are failing';
-    is scalar @{$parser->results->first->details}, 33, '33 test cases details';
-    is $_->{result}, 'fail', 'All testcases are failing' for @{$parser->results->first->details};
+    is $_->{result}, 'pass', 'All testcases are failing' for @{$parser->results->first->details};
 
 };
 
@@ -745,7 +708,9 @@ sub serialize_test {
         $parser = $parser_name->new();
         $parser->load($test_result_file);
         $obj_content  = $parser->to_json();
-        $deserialized = $parser_name->new()->from_json($obj_content);
+        diag explain $obj_content;
+        $deserialized = $parser_name->new()->json_decode($obj_content);
+        diag explain $deserialized;
         ok "$deserialized" ne "$parser", "Different objects";
         $test_function->($parser);
         $test_function->($deserialized);
diff --git a/t/data/tap_format_example.tap b/t/data/tap_format_example.tap
index e15ca27e..f308ae53 100644
--- a/t/data/tap_format_example.tap
+++ b/t/data/tap_format_example.tap
@@ -1,356 +1,12 @@
-t/05-scheduler-dependencies.t .. 
-[DEBUG] Attempt to find job 1/1
-[DEBUG] DB was updated to reflect system status
-[DEBUG] Got job 99983
-[DEBUG] [Job#99983] Prepare for being processed by worker 3
-ok 1 - lowest prio of jobs without parents
-ok 2 - same vlan for whole group
-[DEBUG] Attempt to find job 1/1
-[DEBUG] DB was updated to reflect system status
-[DEBUG] Got job 99984
-[DEBUG] [Job#99984] Prepare for being processed by worker 4
-ok 3 - direct child of B
-ok 4 - same vlan for whole group
-[DEBUG] Attempt to find job 1/1
-[DEBUG] DB was updated to reflect system status
-[DEBUG] Got job 99987
-[DEBUG] [Job#99987] Prepare for being processed by worker 5
-ok 5 - direct child of C
-ok 6 - same vlan for whole group
-[DEBUG] Attempt to find job 1/1
-[DEBUG] DB was updated to reflect system status
-[DEBUG] Got job 99982
-[DEBUG] [Job#99982] Prepare for being processed by worker 6
-ok 7 - E is direct child of C, but A and D must be started first
-ok 8 - same vlan for whole group
-[DEBUG] Attempt to find job 1/1
-[DEBUG] DB was updated to reflect system status
-[DEBUG] Got job 99985
-[DEBUG] [Job#99985] Prepare for being processed by worker 7
-ok 9 - direct child of A
-ok 10 - same vlan for whole group
-[DEBUG] Attempt to find job 1/1
-[DEBUG] DB was updated to reflect system status
-[DEBUG] Got job 99986
-[DEBUG] [Job#99986] Prepare for being processed by worker 8
-ok 11 - C and D are now running so we can start E
-ok 12 - same vlan for whole group
-[DEBUG] dispatching IPC ws_send to websockets: [7, "cancel", 99985]
-[DEBUG] IPC calling ws_send
-[DEBUG] IPC finished
-[DEBUG] dispatching IPC ws_send to websockets: [8, "cancel", 99986]
-[DEBUG] IPC calling ws_send
-[DEBUG] IPC finished
-ok 13 - job_set_done
-[DEBUG] dispatching IPC ws_send to websockets: [8, "cancel", 99986]
-[DEBUG] IPC calling ws_send
-[DEBUG] IPC finished
-ok 14 - job_set_done
-ok 15 - job_set_done
-ok 16 - job_set_done changed state
-ok 17 - job_set_done changed result
-ok 18 - job_set_done changed state
-ok 19 - job_set_done changed state
-ok 20 - job_set_done changed state
-ok 21 - job_set_done changed result, jobD failed because of jobA
-ok 22 - job_set_done changed state
-ok 23 - job_set_done changed result, jobE failed because of jobD
-ok 24 - job_set_done changed state
-[debug] GET "/api/v1/mm/children/running"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.006909s, 144.739/s)
-ok 25 - GET /api/v1/mm/children/running
-ok 26 - 200 OK
-ok 27 - exact match for JSON Pointer "/jobs"
-[debug] GET "/api/v1/mm/children/scheduled"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.00455s, 219.780/s)
-ok 28 - GET /api/v1/mm/children/scheduled
-ok 29 - 200 OK
-ok 30 - exact match for JSON Pointer "/jobs"
-[debug] GET "/api/v1/mm/children/done"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.004425s, 225.989/s)
-ok 31 - GET /api/v1/mm/children/done
-ok 32 - 200 OK
-ok 33 - exact match for JSON Pointer "/jobs"
-[debug] enqueuing abort for 99984 4
-[debug] dispatching IPC ws_send to websockets: [4, "abort", 99984]
-[debug] IPC calling ws_send
-[debug] IPC finished
-[debug] enqueuing abort for 99983 3
-[debug] dispatching IPC ws_send to websockets: [3, "abort", 99983]
-[debug] IPC calling ws_send
-[debug] IPC finished
-[debug] new job 99990
-ok 34 - duplicate works
-ok 35 - no change
-ok 36 - no change
-ok 37 - no clones
-ok 38 - no change
-ok 39 - cloned
-ok 40 - no change
-ok 41 - cloned
-ok 42 - no change
-ok 43 - no change
-ok 44 - no clones
-ok 45 - no change
-ok 46 - no change
-ok 47 - no clones
-ok 48 - no change
-ok 49 - cloned
-ok 50 - cloned jobs are scheduled
-ok 51 - no clones
-ok 52 - cloned jobs are scheduled
-ok 53 - no clones
-ok 54 - cloned deps
-ok 55 - cloned jobs are scheduled
-ok 56 - no clones
-ok 57 - cloned deps
-[debug] GET "/api/v1/mm/children/running"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.003718s, 268.962/s)
-ok 58 - GET /api/v1/mm/children/running
-ok 59 - 200 OK
-ok 60 - exact match for JSON Pointer "/jobs"
-[debug] GET "/api/v1/mm/children/scheduled"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.003664s, 272.926/s)
-ok 61 - GET /api/v1/mm/children/scheduled
-ok 62 - 200 OK
-ok 63 - exact match for JSON Pointer "/jobs"
-[debug] GET "/api/v1/mm/children/done"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.003662s, 273.075/s)
-ok 64 - GET /api/v1/mm/children/done
-ok 65 - 200 OK
-ok 66 - exact match for JSON Pointer "/jobs"
-[debug] new job 99993
-ok 67 - duplicate works
-ok 68 - no change
-ok 69 - no change
-ok 70 - cloned
-ok 71 - no change
-ok 72 - cloned
-ok 73 - no change
-ok 74 - cloned
-ok 75 - no change
-ok 76 - no change
-ok 77 - cloned
-ok 78 - no change
-ok 79 - no change
-ok 80 - cloned
-ok 81 - no change
-ok 82 - cloned
-ok 83 - no change
-ok 84 - no clones
-ok 85 - cloned deps
-ok 86 - no change
-ok 87 - no clones
-ok 88 - cloned deps
-ok 89 - no change
-ok 90 - no clones
-ok 91 - cloned deps
-ok 92 - no change
-ok 93 - no clones
-ok 94 - cloned deps
-ok 95 - no change
-ok 96 - no clones
-ok 97 - cloned deps
-ok 98 - no change
-ok 99 - no clones
-ok 100 - cloned deps
-[debug] GET "/api/v1/mm/children/running"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.003561s, 280.820/s)
-ok 101 - GET /api/v1/mm/children/running
-ok 102 - 200 OK
-ok 103 - exact match for JSON Pointer "/jobs"
-[debug] GET "/api/v1/mm/children/scheduled"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.003297s, 303.306/s)
-ok 104 - GET /api/v1/mm/children/scheduled
-ok 105 - 200 OK
-ok 106 - exact match for JSON Pointer "/jobs"
-[debug] GET "/api/v1/mm/children/done"
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1" and action "auth_jobtoken"
-[debug] Received JobToken: qjwJxfrJnuDdpqZ4
-[debug] Found associated job 99984
-[debug] Routing to controller "OpenQA::WebAPI::Controller::API::V1::Mm" and action "get_children_status"
-[debug] 200 OK (0.003353s, 298.240/s)
-ok 107 - GET /api/v1/mm/children/done
-ok 108 - 200 OK
-ok 109 - exact match for JSON Pointer "/jobs"
-[debug] Attempt to find job 1/1
-[debug] DB was updated to reflect system status
-[debug] Got job 99988
-[debug] [Job#99988] Prepare for being processed by worker 8
-ok 110 - jobB2
-ok 111 - different vlan
-ok 112 - jobX set to done
-[debug] new job 99996
-ok 113 - jobY parent is now jobX clone
-ok 114 - no clone
-ok 115 - no clone
-ok 116 - jobX2 set to done
-ok 117 - jobY set to done
-[debug] new job 99997
-ok 118 - jobY2 parent is now jobX2
-ok 119 - X no clone
-ok 120 - Y no clone
-ok 121 - jobY2 set to done
-[debug] new job 99999
-ok 122 - child job Y2 has been cloned together with parent X2
-ok 123 - jobY3 parent is now jobX3
-[debug] new job 100007
-ok 124 - jobL duplicated
-ok 125 - jobJ cloned
-ok 126 - jobH cloned
-ok 127 - jobK cloned
-ok 128 - J2 cloned with parallel parent dep
-ok 129 - H2 cloned with parallel parent dep
-ok 130 - K2 cloned with parallel children dep
-[debug] new job 100016
-ok 131 - jobU duplicated
-ok 132 - jobQ not cloned
-ok 133 - jobW cloned
-ok 134 - jobU cloned
-ok 135 - jobR cloned
-ok 136 - jobT cloned
-ok 137 - jobQ is chained parent to all jobs
-ok 138 - jobT is parallel child of all jobs except jobQ
-ok 139 - jobW2 has no child dependency to sibling
-ok 140 - jobU2 has no child dependency to sibling
-ok 141 - jobR2 has no child dependency to sibling
-ok 142 - jobW2 has no parent dependency to sibling
-ok 143 - jobU2 has no parent dependency to sibling
-ok 144 - jobR2 has no parent dependency to sibling
-[debug] new job 100021
-ok 145 - jobO duplicated
-ok 146 - jobP cloned
-ok 147 - jobO cloned
-ok 148 - jobI not cloned
-ok 149 - jobI retain its original parent
-ok 150 - clone jobO2 gets new parent jobP2
-[debug] new job 100024
-ok 151 - jobI duplicated
-ok 152 - jobP2 cloned
-ok 153 - jobO2 cloned
-ok 154 - jobI2 got new parent jobO3
-ok 155 - clone jobO3 gets new parent jobP3
-[debug] new job 100029
-ok 156 - jobB duplicated
-ok 157 - jobBc has jobA as chained parent
-ok 158 - jobBc test and jobB test are equal
-ok 159 - jobC was not cloned
-ok 160 - jobC has jobA as chained parent
-ok 161 - jobBc test and jobB test are equal
-ok 162 - jobD was not cloned
-ok 163 - jobD has jobA as chained parent
-ok 164 - jobBc test and jobB test are equal
-[debug] new job 100033
-ok 165 - jobA duplicated
-[debug] new job 100034
-ok 166 - jobA->clone duplicated
-ok 167 - jobB clone jobBc was cloned
-ok 168 - jobB2 has jobA2 as chained parent
-ok 169 - jobB2 test and jobB test are equal
-ok 170 - jobC was cloned
-ok 171 - jobC2 has jobA2 as chained parent
-ok 172 - jobC2 test and jobC test are equal
-ok 173 - jobD was cloned
-ok 174 - jobD2 has jobA2 as chained parent
-ok 175 - jobD2 test and jobD test are equal
-ok 176 - jobA2 has jobB2, jobC2 and jobD2 as children
-[debug] new job 100042
-ok 177 - job cloned
-ok 178 - job has jobA2 as parent
-ok 179 - job cloned
-ok 180 - job has jobA2 as parent
-ok 181 - job cloned
-ok 182 - job has jobA2 as parent
-ok 183 - jobA2 is indeed jobA clone
-[debug] new job 100043
-ok 184 - job correctly not cloned
-ok 185 - job has jobA3 as parent
-ok 186 - job correctly not cloned
-ok 187 - job has jobA3 as parent
-ok 188 - job correctly not cloned
-ok 189 - job has jobA3 as parent
-[debug] new job 100051
-ok 190 - job cloned
-ok 191 - job has jobA2 as parent
-ok 192 - job cloned
-ok 193 - job has jobA2 as parent
-ok 194 - job cloned
-ok 195 - job has jobA2 as parent
-ok 196 - job has jobB2 as parallel parent
-ok 197 - job has jobB2 as parallel parent
-# Subtest: slepos test workers
-    ok 1 - jobA has a clone
-    ok 2 - jobB has a clone
-    ok 3 - jobA is Parallel parent of jobB
-    ok 4 - cloneA is Parallel parent of cloneB
-    ok 5 - jobSUS and jobAS
-    ok 6 - jobA has a clone
-    ok 7 - jobB has a clone
-    ok 8 - jobA is Parallel parent of jobB
-    ok 9 - cloneA is Parallel parent of cloneB
-    ok 10 - jobSUS and jobIS
-    ok 11 - jobA has a clone
-    ok 12 - jobB has a clone
-    ok 13 - jobA is Parallel parent of jobB
-    ok 14 - cloneA is Parallel parent of cloneB
-    ok 15 - jobSUS and jobBS
-    ok 16 - jobA has a clone
-    ok 17 - jobB has a clone
-    ok 18 - jobA is Chained parent of jobB
-    ok 19 - cloneA is Chained parent of cloneB
-    ok 20 - jobAS and jobIS
-    ok 21 - jobA has a clone
-    ok 22 - jobB has a clone
-    ok 23 - jobA is Chained parent of jobB
-    ok 24 - cloneA is Chained parent of cloneB
-    ok 25 - jobAS and jobIS2
-    ok 26 - jobA has a clone
-    ok 27 - jobB has a clone
-    ok 28 - jobA is Parallel parent of jobB
-    ok 29 - cloneA is Parallel parent of cloneB
-    ok 30 - jobAS and jobBS
-    ok 31 - jobA has a clone
-    ok 32 - jobB has a clone
-    ok 33 - jobA is Parallel parent of jobB
-    ok 34 - cloneA is Parallel parent of cloneB
-    ok 35 - jobBS and jobT
-    1..35
-ok 198 - slepos test workers
-ok 199 - no (unexpected) warnings (via done_testing)
-1..199
-ok
-All tests successful.
-Files=1, Tests=199,  8 wallclock secs ( 0.04 usr  0.00 sys +  3.72 cusr  0.13 csys =  3.89 CPU)
-Result: PASS
+t/tap_format_example.tap ..
+1..6
+#
+# Create a new Board and Tile, then place
+# the Tile onto the board.
+#
+ok 1 - The object isa Board
+ok 2 - Board size is zero
+ok 3 - The object isa Tile
+ok 4 - Get possible places to put the Tile
+ok 5 - Placing the tile produces no error
+ok 6 - Board size is 1
